---
domain: ai-philosophy
tags: [clawdbot, claude-code, claude-mem, memory, context, technical-research]
date: 2026-01-30
source_project: "K_Kiro_Work"
related_discussions:
  - "knowledge-base/notes/20260129-超长记忆上下文与AI自我唤醒完整方案.md"
  - "knowledge-base/notes/20260129-今日对话总结.md"
value_score: 10
---

# Clawdbot / Claude Code 超长记忆上下文技术调研报告

> **调研目标**: 了解 Clawdbot / Claude Code 的超长记忆上下文实现原理，为 Kiro Knowledge Base 插件提供技术参考

**创建时间**: 2026-01-30  
**调研人**: Kiro AI + 用户协作  
**版本**: v1.0

---

## 🎯 核心发现

### 概念澄清

**Clawdbot** 和 **Claude Code** 是两个不同但相关的概念：

1. **Claude Code** = Anthropic 官方的 AI 编程助手（类似 Cursor）
2. **Clawdbot** = 第三方工具，连接 Claude 到消息平台（WhatsApp, Telegram 等）
3. **Claude-Mem** = 开源插件，为 Claude Code 添加超长记忆功能 ⭐

**关键洞察**: Claude-Mem 是最接近我们需求的开源方案！

---

## 🧠 超长记忆上下文的实现原理

### 1. Anthropic 官方方案（Claude Agent SDK）

#### 核心技术

**A. Context Compaction（上下文压缩）**
- 自动压缩对话历史
- 保留关键信息
- 避免上下文窗口溢出

**B. Memory Tool（记忆工具）**
- 文件系统存储
- 跨会话持久化
- CRUD 操作（创建、读取、更新、删除）

**C. Long-Running Agent Harness（长期运行代理框架）**

两个关键角色：

1. **Initializer Agent（初始化代理）**
   - 首次会话设置环境
   - 创建 `init.sh` 脚本
   - 创建 `claude-progress.txt` 进度日志
   - 创建 `features.json` 功能清单（200+ 功能）
   - 初始化 Git 仓库

2. **Coding Agent（编码代理）**
   - 后续会话增量工作
   - 读取进度日志和 Git 历史
   - 一次只做一个功能
   - 提交代码，保持清洁状态
   - 更新进度日志

#### 关键文件

```
project/
├── init.sh                 # 初始化脚本（启动开发服务器）
├── claude-progress.txt     # 进度日志（每次会话更新）
├── features.json           # 功能清单（200+ 功能，标记完成状态）
└── .git/                   # Git 历史（代码提交记录）
```

#### 工作流程

```
Session 1 (Initializer Agent):
  ↓
创建环境（init.sh, features.json, claude-progress.txt）
  ↓
初始化 Git 仓库
  ↓
Session 2+ (Coding Agent):
  ↓
读取 claude-progress.txt 和 Git 历史
  ↓
选择一个未完成的功能
  ↓
实现功能 + 测试
  ↓
提交 Git + 更新进度日志
  ↓
重复...
```

#### 关键设计原则

1. **增量进步**：一次只做一个功能，避免一次性做太多
2. **清洁状态**：每次会话结束时代码可合并到主分支
3. **结构化更新**：使用 JSON 格式记录功能状态
4. **端到端测试**：使用浏览器自动化工具（Puppeteer）测试

---

### 2. Claude-Mem 开源方案（推荐学习）⭐

**这个最接近我们的需求！**

#### 项目信息

- **GitHub**: https://github.com/thedotmack/claude-mem
- **文档**: https://docs.claude-mem.ai/
- **许可**: AGPL-3.0（开源）
- **技术栈**: TypeScript, Bun, SQLite, Chroma

#### 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│ Session Start → 注入最近 10 次会话的上下文                   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ User Prompts → 创建会话，保存用户提示                        │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ Tool Executions → 捕获观察（读取、写入等）                   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ Worker Processes → 通过 Claude Agent SDK 提取学习内容        │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ Session Ends → 生成摘要，为下次会话做准备                    │
└─────────────────────────────────────────────────────────────┘
```

#### 核心组件

**1. 生命周期钩子系统（5 个钩子）**


```typescript
interface LifecycleHooks {
  SessionStart: () => Promise<void>;      // 会话开始
  UserPromptSubmit: () => Promise<void>;  // 用户提交提示
  PostToolUse: () => Promise<void>;       // 工具使用后
  Stop: () => Promise<void>;              // 停止
  SessionEnd: () => Promise<void>;        // 会话结束
}
```

**2. Worker Service（HTTP API）**

- 端口：37777
- Web UI 可视化（实时记忆流）
- 10 个搜索端点
- 使用 Bun 管理进程

**3. SQLite 数据库**

```sql
-- 会话表
CREATE TABLE sessions (
  id TEXT PRIMARY KEY,
  project TEXT,
  start_time INTEGER,
  end_time INTEGER,
  summary TEXT
);

-- 观察表
CREATE TABLE observations (
  id TEXT PRIMARY KEY,
  session_id TEXT,
  type TEXT,  -- 'read', 'write', 'execute', 'search'
  content TEXT,
  metadata TEXT,
  timestamp INTEGER,
  FOREIGN KEY (session_id) REFERENCES sessions(id)
);

-- FTS5 全文搜索
CREATE VIRTUAL TABLE observations_fts USING fts5(
  content,
  metadata,
  content='observations'
);
```

**4. Chroma 向量数据库**

- 混合搜索（语义 + 关键词）
- 智能上下文检索
- 本地优先

**5. MCP 搜索工具（3 层工作流）⭐**

这是 Claude-Mem 最聪明的设计！

```typescript
// 第 1 层：快速索引搜索（50-100 tokens/结果）
interface SearchResult {
  id: string;
  type: string;
  timestamp: number;
  snippet: string;  // 只返回摘要
}

// 第 2 层：时间线上下文
interface Timeline {
  before: Observation[];  // 前后各 5 条
  target: Observation;
  after: Observation[];
}

// 第 3 层：完整详情（500-1000 tokens/结果）
interface Observation {
  id: string;
  session_id: string;
  type: string;
  content: string;  // 完整内容
  metadata: any;
  timestamp: number;
}
```

**为什么是 3 层？**
- **节省 Token**：不一次性加载所有内容
- **渐进式披露**：先看索引，再看时间线，最后看详情
- **智能过滤**：只获取真正需要的内容

**6. Folder Context Files（`CLAUDE.md`）⭐**

这是另一个聪明的设计！

```markdown
# Kiro Context - ProjectName

## Recent Activity
- 2026-01-30 10:30 - 实现了 SQLite 数据库
- 2026-01-30 11:00 - 添加了 FTS5 全文搜索
- 2026-01-30 14:00 - 集成了 Chroma 向量数据库

## Key Learnings
- SQLite FTS5 性能很好，适合本地搜索
- Chroma 支持混合搜索，语义理解强
- 3 层搜索工作流可以节省大量 Token

## Current State
- 数据库：已完成
- 搜索：已完成
- UI：进行中
- 测试：待开始

## Next Steps
1. 实现 Web UI
2. 添加测试
3. 优化性能
```

**自动生成**：
- 每次会话结束时更新
- 包含活动时间线
- 提取关键学习内容
- 记录当前状态

#### 关键特性

- 🧠 **持久化记忆** - 上下文跨会话存活
- 📁 **文件夹上下文** - 自动生成 `CLAUDE.md`
- 🌐 **多语言支持** - 28 种语言
- 🎭 **模式系统** - 切换工作流（Code, Email, Chill）
- 🔍 **自然语言查询** - 查询项目历史
- 🌐 **Web UI** - 实时记忆流可视化（http://localhost:37777）
- 🔒 **隐私控制** - `<private>` 标签排除敏感内容
- ⚙️ **上下文配置** - 细粒度控制注入内容
- 🤖 **自动操作** - 无需手动干预
- 📊 **FTS5 搜索** - 快速全文搜索
- 🔗 **引用** - 通过 ID 引用过去的观察

#### 工作流程示例


```typescript
// 用户提问："如何实现登录功能？"

// Step 1: 搜索索引（快速）
const results = await search("login authentication");
// 返回：[
//   { id: "obs_123", type: "read", snippet: "读取了 auth.ts..." },
//   { id: "obs_456", type: "write", snippet: "实现了 login()..." },
//   { id: "obs_789", type: "execute", snippet: "测试了登录流程..." }
// ]

// Step 2: 获取时间线（上下文）
const timeline = await getTimeline("obs_456");
// 返回：前后各 5 条观察，了解上下文

// Step 3: 获取完整详情（只获取需要的）
const details = await getObservations(["obs_456", "obs_789"]);
// 返回：完整的实现代码和测试结果
```

---

## 💡 对我们的启发

### 可以直接借鉴的设计

#### 1. 生命周期钩子系统 ✅

**我们已经有 Hook 系统了！**

可以扩展为类似的生命周期钩子：

```typescript
// 现有的 Hook 系统
interface Hook {
  when: {
    type: 'fileEdited' | 'fileCreated' | 'fileDeleted' | 
          'userTriggered' | 'promptSubmit' | 'agentStop';
    patterns?: string[];
  };
  then: {
    type: 'askAgent' | 'runCommand';
    prompt?: string;
    command?: string;
  };
}

// 扩展为生命周期钩子
interface LifecycleHook extends Hook {
  when: {
    type: 'sessionStart' | 'sessionEnd' | 'toolUse' | 
          'promptSubmit' | 'agentStop';
  };
  then: {
    type: 'captureObservation' | 'generateSummary' | 
          'injectContext' | 'updateProgress';
  };
}
```

#### 2. SQLite + FTS5 全文搜索 ✅

**轻量级，本地优先，不需要额外服务**

```typescript
// 数据库结构
interface Database {
  sessions: Session[];
  observations: Observation[];
  summaries: Summary[];
}

// FTS5 全文搜索
const searchResults = await db.query(`
  SELECT id, type, timestamp, snippet(observations_fts, 2, '<b>', '</b>', '...', 32)
  FROM observations_fts
  WHERE observations_fts MATCH ?
  ORDER BY rank
  LIMIT 20
`, [query]);
```

#### 3. 3 层搜索工作流 ✅

**节省 Token 的关键设计！**

```typescript
class MemorySearch {
  // 第 1 层：快速索引搜索（50-100 tokens/结果）
  async searchIndex(query: string): Promise<SearchResult[]> {
    return await db.query(`
      SELECT 
        id, 
        type, 
        timestamp, 
        snippet(observations_fts, 2, '', '', '...', 50) as snippet
      FROM observations_fts
      WHERE observations_fts MATCH ?
      ORDER BY rank
      LIMIT 20
    `, [query]);
  }
  
  // 第 2 层：时间线上下文
  async getTimeline(observationId: string, radius: number = 5): Promise<Timeline> {
    const target = await db.get('SELECT * FROM observations WHERE id = ?', [observationId]);
    const before = await db.all(`
      SELECT * FROM observations
      WHERE timestamp < ? AND session_id = ?
      ORDER BY timestamp DESC
      LIMIT ?
    `, [target.timestamp, target.session_id, radius]);
    const after = await db.all(`
      SELECT * FROM observations
      WHERE timestamp > ? AND session_id = ?
      ORDER BY timestamp ASC
      LIMIT ?
    `, [target.timestamp, target.session_id, radius]);
    
    return { before: before.reverse(), target, after };
  }
  
  // 第 3 层：完整详情（500-1000 tokens/结果）
  async getObservations(ids: string[]): Promise<Observation[]> {
    return await db.all(`
      SELECT * FROM observations
      WHERE id IN (${ids.map(() => '?').join(',')})
    `, ids);
  }
}
```

#### 4. Folder Context Files（`KIRO.md`）⭐

**这个想法太棒了！**

每个项目文件夹自动生成上下文文件：

```typescript
class FolderContextGenerator {
  async generateContext(project: string): Promise<void> {
    const recentSessions = await getRecentSessions(project, 10);
    const timeline = await generateTimeline(recentSessions);
    const learnings = await extractLearnings(recentSessions);
    const currentState = await getCurrentState(project);
    
    const content = `
# Kiro Context - ${project}

> 自动生成于 ${new Date().toISOString()}

## 📅 Recent Activity

${timeline.map(item => `- ${item.date} ${item.time} - ${item.description}`).join('\n')}

## 💡 Key Learnings

${learnings.map(learning => `- ${learning}`).join('\n')}

## 📊 Current State

${currentState}

## 🚀 Next Steps

${await getNextSteps(project)}

---

*This file is auto-generated by Kiro Knowledge Base Plugin*
*Last updated: ${new Date().toLocaleString()}*
    `;
    
    await fs.writeFile(path.join(project, 'KIRO.md'), content);
  }
}
```

**自动更新时机**：
- 会话结束时
- 文件保存时（通过 Hook）
- 用户手动触发

#### 5. Worker Service + Web UI ✅

**HTTP API 提供搜索服务，Web UI 可视化**

```typescript
// Worker Service
import { serve } from 'bun';

serve({
  port: 37777,
  async fetch(req) {
    const url = new URL(req.url);
    
    // API 端点
    if (url.pathname === '/api/search') {
      const query = url.searchParams.get('q');
      const results = await memorySearch.searchIndex(query);
      return Response.json(results);
    }
    
    if (url.pathname === '/api/timeline') {
      const id = url.searchParams.get('id');
      const timeline = await memorySearch.getTimeline(id);
      return Response.json(timeline);
    }
    
    if (url.pathname === '/api/observations') {
      const ids = url.searchParams.get('ids')?.split(',') || [];
      const observations = await memorySearch.getObservations(ids);
      return Response.json(observations);
    }
    
    // Web UI
    if (url.pathname === '/') {
      return new Response(webUI, {
        headers: { 'Content-Type': 'text/html' }
      });
    }
    
    return new Response('Not Found', { status: 404 });
  }
});

console.log('🚀 Kiro Memory Service running at http://localhost:37777');
```

#### 6. 智能压缩（使用 Claude API）✅

**自动提取学习内容，生成语义摘要**

```typescript
class IntelligentCompression {
  async compressSession(session: Session): Promise<Summary> {
    const observations = await getObservations(session.id);
    
    // 使用 Claude API 提取学习内容
    const prompt = `
请分析以下对话记录，提取关键学习内容：

${observations.map(obs => `[${obs.type}] ${obs.content}`).join('\n\n')}

请提取：
1. 技术要点
2. 决策和原因
3. 遇到的问题和解决方案
4. 下一步行动

以简洁的 Markdown 格式输出。
    `;
    
    const summary = await callClaudeAPI(prompt);
    
    return {
      session_id: session.id,
      content: summary,
      timestamp: Date.now()
    };
  }
}
```

---

## 📊 技术对比

| 特性 | Anthropic 官方 | Claude-Mem | 我们的方案 |
|------|---------------|-----------|-----------|
| **存储** | 文件系统 | SQLite + Chroma | SQLite + Chroma |
| **搜索** | 文件读取 | FTS5 + 向量搜索 | FTS5 + 向量搜索 |
| **压缩** | Context Compaction | Claude Agent SDK | Claude API |
| **UI** | 无 | Web UI (37777) | Web UI (37777) |
| **钩子** | 2 个（Init + Coding） | 5 个生命周期 | 扩展现有 Hook |
| **上下文文件** | `claude-progress.txt` | `CLAUDE.md` | `KIRO.md` |
| **跨项目** | ❌ 不支持 | ❌ 不支持 | ✅ 支持 |
| **来源追踪** | ❌ 不支持 | ❌ 不支持 | ✅ 支持 |
| **Skills 生成** | ❌ 不支持 | ❌ 不支持 | ✅ 支持 |
| **多 AI 支持** | ❌ 只支持 Claude | ❌ 只支持 Claude | ✅ 支持多个 |
| **开源** | 部分开源 | 完全开源 (AGPL-3.0) | 完全开源 |

---

## 🚀 我们的实现方案（更新）

### Phase 1: 基础架构（v2.5.0）- 立即可做

**借鉴 Claude-Mem 的设计**：

#### 1. SQLite 数据库 + FTS5 全文搜索

```sql
-- 会话表
CREATE TABLE sessions (
  id TEXT PRIMARY KEY,
  project TEXT NOT NULL,
  start_time INTEGER NOT NULL,
  end_time INTEGER,
  summary TEXT,
  metadata TEXT  -- JSON: { tags, context, etc. }
);

-- 观察表
CREATE TABLE observations (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  type TEXT NOT NULL,  -- 'read', 'write', 'execute', 'search', 'discuss'
  content TEXT NOT NULL,
  metadata TEXT,  -- JSON: { file_path, line_number, etc. }
  timestamp INTEGER NOT NULL,
  FOREIGN KEY (session_id) REFERENCES sessions(id)
);

-- 摘要表
CREATE TABLE summaries (
  id TEXT PRIMARY KEY,
  session_id TEXT NOT NULL,
  content TEXT NOT NULL,
  learnings TEXT,  -- JSON: [learning1, learning2, ...]
  timestamp INTEGER NOT NULL,
  FOREIGN KEY (session_id) REFERENCES sessions(id)
);

-- FTS5 全文搜索
CREATE VIRTUAL TABLE observations_fts USING fts5(
  content,
  metadata,
  content='observations',
  content_rowid='rowid'
);

-- 触发器：自动更新 FTS5 索引
CREATE TRIGGER observations_ai AFTER INSERT ON observations BEGIN
  INSERT INTO observations_fts(rowid, content, metadata)
  VALUES (new.rowid, new.content, new.metadata);
END;

CREATE TRIGGER observations_ad AFTER DELETE ON observations BEGIN
  DELETE FROM observations_fts WHERE rowid = old.rowid;
END;

CREATE TRIGGER observations_au AFTER UPDATE ON observations BEGIN
  UPDATE observations_fts 
  SET content = new.content, metadata = new.metadata
  WHERE rowid = new.rowid;
END;
```

#### 2. 生命周期钩子扩展

```json
// .kiro/hooks/memory-capture.json
{
  "name": "Memory Capture",
  "version": "1.0.0",
  "description": "自动捕获对话记录到记忆系统",
  "when": {
    "type": "promptSubmit"
  },
  "then": {
    "type": "askAgent",
    "prompt": "捕获这次对话到记忆系统"
  }
}

// .kiro/hooks/session-summary.json
{
  "name": "Session Summary",
  "version": "1.0.0",
  "description": "会话结束时生成摘要",
  "when": {
    "type": "agentStop"
  },
  "then": {
    "type": "askAgent",
    "prompt": "生成本次会话的摘要并保存"
  }
}

// .kiro/hooks/context-injection.json
{
  "name": "Context Injection",
  "version": "1.0.0",
  "description": "会话开始时注入相关上下文",
  "when": {
    "type": "userTriggered"
  },
  "then": {
    "type": "askAgent",
    "prompt": "读取 KIRO.md 并注入相关上下文"
  }
}
```

#### 3. Folder Context Files（`KIRO.md`）

```typescript
// 自动生成 KIRO.md
interface KiroContext {
  project: string;
  lastUpdated: Date;
  recentActivity: Activity[];
  keyLearnings: string[];
  currentState: string;
  nextSteps: string[];
}

class KiroContextGenerator {
  async generate(project: string): Promise<string> {
    const context = await this.buildContext(project);
    
    return `
# Kiro Context - ${context.project}

> 🤖 自动生成于 ${context.lastUpdated.toLocaleString()}
> 📍 项目路径: ${project}

---

## 📅 Recent Activity

${context.recentActivity.map(activity => 
  `- **${activity.date}** ${activity.time} - ${activity.description}`
).join('\n')}

---

## 💡 Key Learnings

${context.keyLearnings.map((learning, i) => 
  `${i + 1}. ${learning}`
).join('\n')}

---

## 📊 Current State

${context.currentState}

---

## 🚀 Next Steps

${context.nextSteps.map((step, i) => 
  `${i + 1}. ${step}`
).join('\n')}

---

## 🔍 Quick Search

使用以下命令搜索项目历史：
\`\`\`
# 搜索关键词
kiro search "login authentication"

# 查看时间线
kiro timeline <observation-id>

# 获取详情
kiro get <observation-id>
\`\`\`

---

*This file is auto-generated by Kiro Knowledge Base Plugin*  
*Do not edit manually - changes will be overwritten*  
*Last updated: ${context.lastUpdated.toISOString()}*
    `.trim();
  }
  
  private async buildContext(project: string): Promise<KiroContext> {
    const sessions = await getRecentSessions(project, 10);
    const observations = await getRecentObservations(project, 50);
    
    return {
      project,
      lastUpdated: new Date(),
      recentActivity: await this.extractActivity(observations),
      keyLearnings: await this.extractLearnings(sessions),
      currentState: await this.analyzeCurrentState(project),
      nextSteps: await this.suggestNextSteps(sessions)
    };
  }
}
```

#### 4. 3 层搜索 API

```typescript
// API 实现
class MemoryAPI {
  // Layer 1: 快速索引搜索
  async search(query: string, options?: SearchOptions): Promise<SearchResult[]> {
    const sql = `
      SELECT 
        o.id,
        o.type,
        o.timestamp,
        s.project,
        snippet(observations_fts, 2, '<mark>', '</mark>', '...', 50) as snippet
      FROM observations_fts
      JOIN observations o ON observations_fts.rowid = o.rowid
      JOIN sessions s ON o.session_id = s.id
      WHERE observations_fts MATCH ?
      ${options?.project ? 'AND s.project = ?' : ''}
      ${options?.type ? 'AND o.type = ?' : ''}
      ${options?.startDate ? 'AND o.timestamp >= ?' : ''}
      ${options?.endDate ? 'AND o.timestamp <= ?' : ''}
      ORDER BY rank
      LIMIT ${options?.limit || 20}
    `;
    
    const params = [query];
    if (options?.project) params.push(options.project);
    if (options?.type) params.push(options.type);
    if (options?.startDate) params.push(options.startDate);
    if (options?.endDate) params.push(options.endDate);
    
    return await db.all(sql, params);
  }
  
  // Layer 2: 时间线上下文
  async timeline(observationId: string, radius: number = 5): Promise<Timeline> {
    const target = await db.get(
      'SELECT * FROM observations WHERE id = ?',
      [observationId]
    );
    
    if (!target) throw new Error('Observation not found');
    
    const before = await db.all(`
      SELECT * FROM observations
      WHERE timestamp < ? AND session_id = ?
      ORDER BY timestamp DESC
      LIMIT ?
    `, [target.timestamp, target.session_id, radius]);
    
    const after = await db.all(`
      SELECT * FROM observations
      WHERE timestamp > ? AND session_id = ?
      ORDER BY timestamp ASC
      LIMIT ?
    `, [target.timestamp, target.session_id, radius]);
    
    return {
      before: before.reverse(),
      target,
      after
    };
  }
  
  // Layer 3: 完整详情
  async getObservations(ids: string[]): Promise<Observation[]> {
    if (ids.length === 0) return [];
    
    const placeholders = ids.map(() => '?').join(',');
    return await db.all(`
      SELECT o.*, s.project, s.summary as session_summary
      FROM observations o
      JOIN sessions s ON o.session_id = s.id
      WHERE o.id IN (${placeholders})
    `, ids);
  }
}
```

**时间**: 1-2 周

---

### Phase 2: 超长记忆（v2.6.0）- Clawdbot 机制

#### 技术栈选择

1. **SQLite + FTS5**（基础搜索）✅
   - 轻量级，本地优先
   - 全文搜索性能好
   - 不需要额外服务

2. **Chroma 向量数据库**（语义搜索）✅
   - 开源，本地优先
   - 支持混合搜索（语义 + 关键词）
   - 易于集成

3. **Claude API**（智能压缩）✅
   - 自动提取学习内容
   - 生成语义摘要
   - 保留关键信息

#### 实现步骤


**1. 集成 Chroma 向量数据库**

```typescript
import { ChromaClient } from 'chromadb';

class VectorMemory {
  private client: ChromaClient;
  private collection: any;
  
  async initialize() {
    this.client = new ChromaClient();
    this.collection = await this.client.getOrCreateCollection({
      name: 'kiro_memory',
      metadata: { 'hnsw:space': 'cosine' }
    });
  }
  
  async addObservation(observation: Observation) {
    // 生成 Embedding（使用 Claude API 或本地模型）
    const embedding = await generateEmbedding(observation.content);
    
    await this.collection.add({
      ids: [observation.id],
      embeddings: [embedding],
      metadatas: [{
        session_id: observation.session_id,
        type: observation.type,
        timestamp: observation.timestamp,
        project: observation.project
      }],
      documents: [observation.content]
    });
  }
  
  async semanticSearch(query: string, topK: number = 10): Promise<SearchResult[]> {
    const queryEmbedding = await generateEmbedding(query);
    
    const results = await this.collection.query({
      queryEmbeddings: [queryEmbedding],
      nResults: topK
    });
    
    return results.ids[0].map((id, i) => ({
      id,
      distance: results.distances[0][i],
      content: results.documents[0][i],
      metadata: results.metadatas[0][i]
    }));
  }
  
  async hybridSearch(query: string, topK: number = 10): Promise<SearchResult[]> {
    // 混合搜索：FTS5 + 向量搜索
    const ftsResults = await memoryAPI.search(query, { limit: topK });
    const vectorResults = await this.semanticSearch(query, topK);
    
    // 合并并重新排序
    return this.mergeAndRank(ftsResults, vectorResults);
  }
}
```

**2. 智能压缩（使用 Claude API）**

```typescript
class IntelligentCompression {
  async compressSession(sessionId: string): Promise<Summary> {
    const observations = await getObservations(sessionId);
    
    // 构建压缩提示
    const prompt = `
请分析以下对话记录，提取关键学习内容：

${observations.map(obs => `
[${obs.type}] ${new Date(obs.timestamp).toLocaleString()}
${obs.content}
`).join('\n---\n')}

请提取：
1. **技术要点**：关键的技术决策和实现细节
2. **问题和解决方案**：遇到的问题及如何解决
3. **重要决策**：做出的决策及原因
4. **下一步行动**：未完成的任务和计划

以简洁的 Markdown 格式输出，每个部分不超过 3 条。
    `;
    
    const summary = await callClaudeAPI(prompt);
    
    // 保存摘要
    await db.run(`
      INSERT INTO summaries (id, session_id, content, timestamp)
      VALUES (?, ?, ?, ?)
    `, [generateId(), sessionId, summary, Date.now()]);
    
    return { session_id: sessionId, content: summary };
  }
  
  async extractLearnings(sessionId: string): Promise<string[]> {
    const summary = await getSummary(sessionId);
    
    // 使用 Claude API 提取学习点
    const prompt = `
从以下摘要中提取关键学习点，每个学习点一句话：

${summary.content}

输出格式：
- 学习点 1
- 学习点 2
- 学习点 3
    `;
    
    const learnings = await callClaudeAPI(prompt);
    return learnings.split('\n').filter(l => l.trim().startsWith('-')).map(l => l.trim().substring(2));
  }
}
```

**3. 自动上下文注入**

```typescript
class ContextInjection {
  async injectContext(project: string, query: string): Promise<string> {
    // 1. 读取 KIRO.md
    const kiroContext = await fs.readFile(path.join(project, 'KIRO.md'), 'utf-8');
    
    // 2. 搜索相关历史
    const searchResults = await memoryAPI.search(query, { project, limit: 5 });
    
    // 3. 获取时间线（只获取最相关的）
    const timelines = await Promise.all(
      searchResults.slice(0, 2).map(r => memoryAPI.timeline(r.id, 3))
    );
    
    // 4. 构建上下文
    const context = `
# 项目上下文

${kiroContext}

---

# 相关历史

${searchResults.map(r => `
## ${r.type} - ${new Date(r.timestamp).toLocaleString()}
${r.snippet}
[查看详情: ${r.id}]
`).join('\n')}

---

# 时间线

${timelines.map(t => `
### 围绕 ${t.target.id} 的上下文

**之前**:
${t.before.map(o => `- ${new Date(o.timestamp).toLocaleString()}: ${o.content.substring(0, 100)}...`).join('\n')}

**当前**:
- ${new Date(t.target.timestamp).toLocaleString()}: ${t.target.content.substring(0, 100)}...

**之后**:
${t.after.map(o => `- ${new Date(o.timestamp).toLocaleString()}: ${o.content.substring(0, 100)}...`).join('\n')}
`).join('\n---\n')}
    `;
    
    return context;
  }
}
```

**时间**: 3-4 周

---

### Phase 3: Skills 自动生成（v2.7.0）

**借鉴 Claude-Mem 的模式检测**：

```typescript
class PatternDetector {
  async detectPatterns(project: string): Promise<Pattern[]> {
    // 1. 获取所有观察
    const observations = await getAllObservations(project);
    
    // 2. 聚类相似观察（使用向量相似度）
    const clusters = await this.clusterObservations(observations);
    
    // 3. 提取共同特征
    const patterns = await Promise.all(
      clusters.map(async cluster => {
        const commonSteps = await this.extractCommonSteps(cluster);
        const keywords = await this.extractKeywords(cluster);
        const context = await this.extractContext(cluster);
        
        return {
          frequency: cluster.length,
          commonSteps,
          keywords,
          context,
          observations: cluster
        };
      })
    );
    
    // 4. 过滤高频模式（频率 >= 3）
    return patterns.filter(p => p.frequency >= 3);
  }
  
  private async clusterObservations(observations: Observation[]): Promise<Observation[][]> {
    // 使用向量相似度聚类
    const embeddings = await Promise.all(
      observations.map(o => generateEmbedding(o.content))
    );
    
    // 简单的聚类算法（可以用更复杂的，如 DBSCAN）
    const clusters: Observation[][] = [];
    const visited = new Set<number>();
    
    for (let i = 0; i < observations.length; i++) {
      if (visited.has(i)) continue;
      
      const cluster = [observations[i]];
      visited.add(i);
      
      for (let j = i + 1; j < observations.length; j++) {
        if (visited.has(j)) continue;
        
        const similarity = cosineSimilarity(embeddings[i], embeddings[j]);
        if (similarity > 0.8) {  // 相似度阈值
          cluster.push(observations[j]);
          visited.add(j);
        }
      }
      
      if (cluster.length >= 3) {  // 至少 3 个观察
        clusters.push(cluster);
      }
    }
    
    return clusters;
  }
  
  private async extractCommonSteps(cluster: Observation[]): Promise<string[]> {
    // 使用 Claude API 提取共同步骤
    const prompt = `
分析以下相似的操作记录，提取共同的步骤：

${cluster.map((o, i) => `
## 记录 ${i + 1}
${o.content}
`).join('\n')}

请提取共同的步骤，每个步骤一句话。
    `;
    
    const steps = await callClaudeAPI(prompt);
    return steps.split('\n').filter(s => s.trim()).map(s => s.trim());
  }
}

class SkillGenerator {
  async generateSkill(pattern: Pattern): Promise<Skill> {
    // 1. 生成 Skill 名称
    const name = await this.generateSkillName(pattern.keywords);
    
    // 2. 生成描述
    const description = await this.summarizePattern(pattern);
    
    // 3. 生成步骤
    const steps = pattern.commonSteps.map((step, i) => `${i + 1}. ${step}`).join('\n');
    
    // 4. 生成示例
    const examples = await this.generateExamples(pattern);
    
    // 5. 生成完整的 SKILL.md
    const content = `
---
name: "${name}"
description: "${description}"
frequency: ${pattern.frequency}
keywords: ${JSON.stringify(pattern.keywords)}
---

# ${name}

## 📝 描述

${description}

## 🎯 使用场景

${pattern.context}

## 📋 执行步骤

${steps}

## 💡 示例

${examples}

## 📊 统计

- 使用频率: ${pattern.frequency} 次
- 首次使用: ${new Date(pattern.observations[0].timestamp).toLocaleDateString()}
- 最近使用: ${new Date(pattern.observations[pattern.observations.length - 1].timestamp).toLocaleDateString()}

---

*This skill was auto-generated by Kiro Knowledge Base Plugin*
*Based on ${pattern.frequency} similar observations*
    `.trim();
    
    return {
      name,
      description,
      content,
      metadata: {
        frequency: pattern.frequency,
        keywords: pattern.keywords,
        generated_at: Date.now()
      }
    };
  }
  
  async saveSkill(skill: Skill, project: string): Promise<void> {
    const skillDir = path.join(project, '.trae', 'skills', skill.name);
    await fs.mkdir(skillDir, { recursive: true });
    await fs.writeFile(path.join(skillDir, 'SKILL.md'), skill.content);
  }
}
```

**时间**: 2-3 周

---

### Phase 4: 本地 AI 接口（v3.0.0）

**为"物理 AI 世界"做准备**：

```typescript
// 统一的 AI 接口
interface AIProvider {
  name: string;
  type: 'cloud' | 'local';
  
  // 基础能力
  chat(messages: Message[]): Promise<string>;
  embed(text: string): Promise<number[]>;
  
  // 知识库能力
  loadKnowledge(kb: KnowledgeBase): Promise<void>;
  recall(query: string): Promise<Knowledge[]>;
}

// Kiro 实现
class KiroAI implements AIProvider {
  name = 'Kiro';
  type = 'cloud';
  
  async chat(messages: Message[]): Promise<string> {
    // 调用 Kiro API
    return await kiroAPI.chat(messages);
  }
  
  async embed(text: string): Promise<number[]> {
    // 使用 Claude API 生成 Embedding
    return await claudeAPI.embed(text);
  }
  
  async loadKnowledge(kb: KnowledgeBase): Promise<void> {
    // 加载到 Kiro 的上下文
    // 通过 Steering 规则自动注入
  }
  
  async recall(query: string): Promise<Knowledge[]> {
    // 使用 3 层搜索工作流
    const results = await memoryAPI.search(query);
    return results.map(r => ({
      id: r.id,
      content: r.snippet,
      relevance: r.rank
    }));
  }
}

// Ollama 实现（本地 AI）
class OllamaAI implements AIProvider {
  name = 'Ollama';
  type = 'local';
  
  async chat(messages: Message[]): Promise<string> {
    // 调用 Ollama API
    const response = await fetch('http://localhost:11434/api/chat', {
      method: 'POST',
      body: JSON.stringify({
        model: 'qwen2.5:32b',
        messages
      })
    });
    return await response.json();
  }
  
  async embed(text: string): Promise<number[]> {
    // 使用 Ollama 的 Embedding 模型
    const response = await fetch('http://localhost:11434/api/embeddings', {
      method: 'POST',
      body: JSON.stringify({
        model: 'nomic-embed-text',
        prompt: text
      })
    });
    const data = await response.json();
    return data.embedding;
  }
  
  async loadKnowledge(kb: KnowledgeBase): Promise<void> {
    // 加载到本地模型的上下文
    // 使用 RAG（检索增强生成）
    const relevantDocs = await kb.search(this.currentQuery);
    this.context = relevantDocs.map(d => d.content).join('\n\n');
  }
  
  async recall(query: string): Promise<Knowledge[]> {
    // 使用混合搜索（FTS5 + 向量）
    return await vectorMemory.hybridSearch(query);
  }
}

// 未来可以轻松添加更多 AI
class ClaudeAI implements AIProvider { /* ... */ }
class ChatGPT implements AIProvider { /* ... */ }
class GeminiAI implements AIProvider { /* ... */ }
```

**时间**: 4-6 周

---

## 🎯 立即行动计划（更新）

### 第一步：学习 Claude-Mem 源码 ⭐

**任务**：
1. Clone Claude-Mem 仓库
2. 研究核心实现
3. 理解 3 层搜索工作流
4. 学习 Folder Context Files 生成

**命令**：
```bash
git clone https://github.com/thedotmack/claude-mem.git
cd claude-mem

# 研究关键文件
# - src/hooks/ - 生命周期钩子
# - src/worker/ - Worker Service
# - src/database/ - SQLite 数据库
# - src/search/ - 搜索实现
# - src/context/ - 上下文生成
```

**时间**：1-2 天

---

### 第二步：实现 SQLite + FTS5

**任务**：
1. 创建数据库结构
2. 实现 FTS5 全文搜索
3. 添加基础 CRUD 操作
4. 编写测试

**文件**：
- `src/database/schema.sql` - 数据库结构
- `src/database/db.ts` - 数据库操作
- `src/database/fts.ts` - FTS5 搜索
- `tests/database.test.ts` - 测试

**时间**：1-2 天

---

### 第三步：实现 Folder Context Files

**任务**：
1. 自动生成 `KIRO.md`
2. 包含活动时间线
3. 提取关键学习内容
4. 添加 Hook 自动更新

**文件**：
- `src/context/generator.ts` - 上下文生成器
- `src/context/template.ts` - Markdown 模板
- `.kiro/hooks/update-context.json` - Hook 配置

**时间**：2-3 天

---

### 第四步：实现 3 层搜索 API

**任务**：
1. 实现快速索引搜索
2. 实现时间线上下文
3. 实现完整详情获取
4. 添加 HTTP API

**文件**：
- `src/search/api.ts` - 搜索 API
- `src/search/index.ts` - 索引搜索
- `src/search/timeline.ts` - 时间线
- `src/search/details.ts` - 详情获取

**时间**：3-4 天

---

### 第五步：集成 Chroma 向量数据库

**任务**：
1. 安装 Chroma
2. 实现 Embedding 生成
3. 实现混合搜索
4. 优化性能

**文件**：
- `src/vector/chroma.ts` - Chroma 集成
- `src/vector/embedding.ts` - Embedding 生成
- `src/vector/hybrid.ts` - 混合搜索

**时间**：3-5 天

---

### 第六步：实现 Worker Service + Web UI

**任务**：
1. 创建 HTTP API 服务器
2. 实现搜索端点
3. 创建 Web UI
4. 实时更新（SSE）

**文件**：
- `src/worker/server.ts` - HTTP 服务器
- `src/worker/api.ts` - API 端点
- `src/worker/ui.html` - Web UI
- `src/worker/sse.ts` - 实时更新

**时间**：4-5 天

---

## 💡 关键洞察

### Claude-Mem 的设计哲学

1. **Token 效率优先**
   - 3 层搜索工作流
   - 先索引，再时间线，最后详情
   - 避免一次性加载所有内容

2. **本地优先**
   - SQLite 本地存储
   - Chroma 本地向量数据库
   - 不依赖云服务

3. **自动化**
   - 生命周期钩子自动捕获
   - 自动生成摘要
   - 自动注入上下文

4. **可视化**
   - Web UI 实时监控
   - 时间线可视化
   - 搜索结果可视化

---

### 我们可以做得更好的地方

1. **跨项目关联** ⭐
   - Claude-Mem 只关注单个项目
   - 我们需要跨项目上下文关联
   - 来源追踪和项目分类

2. **Skills 自动生成** ⭐
   - Claude-Mem 没有这个功能
   - 我们可以添加模式检测
   - 自动生成 Skill 文档

3. **多 AI 支持** ⭐
   - 不只是 Claude
   - 支持 Ollama, ChatGPT, Gemini 等
   - 统一的 AI 接口

4. **团队协作** ⭐
   - 多用户支持
   - 知识共享
   - 权限管理

---

## 📚 参考资源

### 官方文档

1. **Anthropic 官方**
   - [Effective Harnesses for Long-Running Agents](https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents)
   - [Context Management](https://www.anthropic.com/news/context-management)
   - [Memory Tool Cookbook](https://platform.claude.com/cookbook/tool-use-memory-cookbook)

2. **Claude-Mem 开源项目**
   - [GitHub Repo](https://github.com/thedotmack/claude-mem)
   - [Documentation](https://docs.claude-mem.ai/)
   - [Architecture Overview](https://docs.claude-mem.ai/architecture)

### 技术栈

1. **SQLite + FTS5**
   - [SQLite FTS5 Documentation](https://www.sqlite.org/fts5.html)
   - [Full-Text Search Best Practices](https://www.sqlite.org/fts5.html#appendix_a)

2. **Chroma 向量数据库**
   - [Chroma Documentation](https://docs.trychroma.com/)
   - [Getting Started](https://docs.trychroma.com/getting-started)
   - [Embeddings Guide](https://docs.trychroma.com/embeddings)

3. **Claude Agent SDK**
   - [Agent SDK Documentation](https://github.com/anthropics/anthropic-sdk-typescript)
   - [Quickstart Guide](https://github.com/anthropics/anthropic-quickstarts)

4. **Bun**
   - [Bun Documentation](https://bun.sh/docs)
   - [SQLite with Bun](https://bun.sh/docs/api/sqlite)

---

## 🎯 预期效果

### 短期（Phase 1-2）

- ✅ 解决跨项目上下文断裂
- ✅ 减少重复讨论
- ✅ 提高知识复用率
- ✅ 实现超长记忆上下文
- ✅ 节省 Token 成本（3 层搜索）

### 中期（Phase 3-4）

- ✅ 自动生成 Skills
- ✅ AI 越用越"懂"你
- ✅ 支持本地 AI
- ✅ 形成个性化"自我"
- ✅ 跨 AI 平台统一知识管理

### 长期（Phase 5+）

- ✅ 多平台统一知识管理
- ✅ 团队知识共享
- ✅ 真正的"AI 自我唤醒"
- ✅ 为"物理 AI 世界"做好准备
- ✅ 独立 App 和 API 服务

---

## 📊 成本估算

### 开发成本

| Phase | 时间 | 人力 | 复杂度 |
|-------|------|------|--------|
| Phase 1 | 1-2 周 | 1 人 | 中等 |
| Phase 2 | 3-4 周 | 1 人 | 大 |
| Phase 3 | 2-3 周 | 1 人 | 中等 |
| Phase 4 | 4-6 周 | 1-2 人 | 大 |
| **总计** | **10-15 周** | **1-2 人** | **大** |

### 运行成本

| 项目 | 成本 | 说明 |
|------|------|------|
| SQLite | 免费 | 本地存储 |
| Chroma | 免费 | 本地向量数据库 |
| Claude API | 按使用量 | 智能压缩和 Embedding |
| Ollama | 免费 | 本地 AI（可选） |
| 服务器 | 免费 | 本地运行 |

**总成本**: 主要是 Claude API 的使用成本，可以通过优化减少。

---

## ✅ 结论

### 核心发现

1. **Claude-Mem 是最接近我们需求的开源方案**
   - 完整的生命周期钩子系统
   - 高效的 3 层搜索工作流
   - 智能的 Folder Context Files
   - 本地优先的技术栈

2. **我们可以在 Claude-Mem 的基础上做得更好**
   - 跨项目上下文关联
   - Skills 自动生成
   - 多 AI 支持
   - 团队协作

3. **技术栈选择明确**
   - SQLite + FTS5（基础搜索）
   - Chroma（语义搜索）
   - Claude API（智能压缩）
   - Bun（运行时）

### 下一步行动

1. **立即开始**：学习 Claude-Mem 源码
2. **快速原型**：实现 Phase 1（1-2 周）
3. **迭代优化**：根据反馈调整
4. **长期规划**：按 Phase 2-4 逐步实现

### 最终目标

**不只是一个插件，而是 AI 的"出生后成长系统"，为"物理 AI 世界"做准备！**

---

**创建时间**: 2026-01-30  
**作者**: Kiro AI + 用户协作  
**版本**: v1.0  
**意义**: 为 Kiro Knowledge Base 插件提供清晰的技术路径和实现方案

