---
inclusion: always
---

# 自动知识库同步

## 🎯 目标

自动同步本地知识库到中央知识库，避免手动操作。

---

## 📋 对话结束时

当对话结束或用户说"保存到知识库"时，你应该：

### 1. 评估对话质量

判断是否值得保存：
- ✅ 包含技术方案或解决方案
- ✅ 包含重要的讨论和决策
- ✅ 包含有价值的笔记和总结
- ❌ 只是简单的问答
- ❌ 没有实质内容

### 2. 确定保存位置

根据内容类型：
- **技术方案** → `solutions/`
- **笔记和总结** → `notes/`
- **讨论和决策** → `discussions/`

### 3. 生成文件名

格式：`YYYYMMDD-主题.md`

例如：
- `20260129-超长记忆上下文与AI自我唤醒完整方案.md`
- `20260129-Kiro-IDE-最佳实践指南.md`

### 4. 添加元数据

**必须包含**:
```yaml
---
domain: [领域]
tags: [标签列表]
date: YYYY-MM-DD
source_project: "K_Kiro_Work"
related_discussions:
  - "path/to/related/doc.md"
value_score: 1-10
---
```

### 5. 提醒用户同步

保存到本地后，提醒用户：
```
✅ 已保存到本地知识库：
   knowledge-base/notes/20260129-xxx.md

⚠️ 请记得同步到中央知识库：
   Copy-Item "knowledge-base\notes\20260129-*.md" "D:\G_GitHub\Kiro-Central-KB\notes\"
```

---

## 🔍 对话开始时

当用户提出问题时，你应该：

### 1. 检查是否需要检索知识库

**🚨 强制触发条件（必须立即执行）**:

#### A. 直接问题触发
用户说以下任何一句话时，**立即**读取对应文档：

| 用户问题 | 立即执行 |
|---------|---------|
| "今天我探讨的什么？" | 读取 `knowledge-base/notes/YYYYMMDD-今日对话总结.md` |
| "今天讨论了什么？" | 读取 `knowledge-base/notes/YYYYMMDD-今日对话总结.md` |
| "继续开发" | 读取 `SESSION-STATE.md` 和最新会话记录 |
| "继续工作" | 读取 `SESSION-STATE.md` 和最新会话记录 |
| "我们之前讨论过..." | 检索中央知识库和本地知识库 |
| "之前说过..." | 检索中央知识库和本地知识库 |
| "保存到知识库" | 评估对话质量并保存 |

#### B. 关键词触发
用户提到以下关键词时，**主动检索**相关讨论：

**技术关键词**:
- Clawdbot, Claude Code → 超长记忆上下文
- Skills → 自动生成机制
- 神经网络 → AI 架构思想
- 胎儿期、成长 → AI 哲学
- 知识库、插件 → 架构设计
- 跨项目、上下文 → 上下文断裂问题
- Hook → 自动化、跨设备
- Ollama, Qwen → 本地 AI 系统
- 向量数据库, ChromaDB → 超长记忆实现

**项目关键词**:
- Kiro-KB-Plugin → 检索插件项目文档
- DevBrain-App → 检索应用项目文档
- K_Kiro_Work → 当前项目
- 中央知识库 → 检索 `D:\G_GitHub\Kiro-Central-KB\`

**时间关键词**:
- "今天" → 读取今日总结
- "昨天" → 读取昨日总结
- "昨晚" → 读取昨日总结
- "最近" → 读取最近 3 天的总结
- "之前" → 检索历史讨论

### 2. 主动检索知识库（不要等用户要求）

**检索顺序**:
1. **本地知识库优先** - 先检索当前项目的 `knowledge-base/`
2. **中央知识库次之** - 再检索 `D:\G_GitHub\Kiro-Central-KB\`
3. **其他项目最后** - 最后检索其他项目文档

**检索步骤**:
```
⚠️ 我发现这个话题之前可能讨论过（关键词：[匹配的关键词]）。

让我先检索知识库...

【本地知识库】
- 搜索 knowledge-base/notes/ 中的相关文档
- 搜索 knowledge-base/solutions/ 中的相关方案

【中央知识库】
- 读取 D:\G_GitHub\Kiro-Central-KB\INDEX.md
- 搜索相关关键词
- 读取找到的文档

【其他项目】
- 搜索 incubator/graduated/Kiro-KB-Plugin/docs/
- 搜索其他相关项目文档

请稍等...
```

**检索后必须做的事**:
1. ✅ 告诉用户找到了什么
2. ✅ 读取相关文档的完整内容
3. ✅ 基于历史上下文回答问题
4. ✅ 避免重复讨论

### 3. 引用相关讨论

如果找到相关讨论：
```
✅ 我在 [日期] 的 [项目名] 中发现了相关讨论：
- [文档标题]
- [文档路径]

让我先读取这些内容，避免重复讨论。
```

---

## 🤖 自动化流程

### 流程 A: 对话结束

```
用户对话结束
  ↓
评估对话质量
  ↓
确定保存位置
  ↓
生成文件名和元数据
  ↓
保存到本地知识库
  ↓
提醒用户同步到中央知识库
```

### 流程 B: 对话开始

```
用户提出问题
  ↓
检查关键词匹配
  ↓
如果匹配，检索中央知识库
  ↓
如果找到相关讨论，读取并引用
  ↓
基于历史上下文回答问题
```

---

## 📝 示例

### 示例 1: 对话结束时

**用户**: "保存到知识库"

**你的回应**:
```
✅ 评估对话质量：包含技术方案和架构设计，值得保存

✅ 保存位置：solutions/

✅ 文件名：20260129-超长记忆上下文与AI自我唤醒完整方案.md

✅ 已保存到：knowledge-base/solutions/20260129-超长记忆上下文与AI自我唤醒完整方案.md

⚠️ 请记得同步到中央知识库：
   Copy-Item "knowledge-base\solutions\20260129-*.md" "D:\G_GitHub\Kiro-Central-KB\solutions\"
```

### 示例 2: 关键词触发检索

**用户**: "Hook 可以实现跨设备上下文恢复吗？"

**你的回应**:
```
⚠️ 我发现这个话题之前可能讨论过（关键词：Hook, 跨设备, 上下文）。

让我先检索知识库...

【本地知识库】
✅ 找到：knowledge-base/notes/20260129-今日对话总结.md
✅ 找到：docs/CROSS-DEVICE-TEST-PLAN.md

【其他项目】
✅ 找到：incubator/graduated/Kiro-KB-Plugin/docs/CROSS-DEVICE-CONTEXT-RECOVERY.md

让我读取这些文档...

[读取文档后]

是的！在 Kiro-KB-Plugin 项目中，我们设计了完整的跨设备上下文恢复机制：

1. **Hook: Sync Documentation on Source Changes**
   - 在源代码变更时自动同步文档

2. **自动上下文恢复（Steering 规则）**
   - 用户说"继续开发"时自动读取 SESSION-STATE.md
   - 自动恢复上下文

3. **跨设备工作流**
   - 离开设备时：更新 SESSION-STATE.md
   - 到达新设备时：让 Kiro 读取文档

这个机制可以应用到 K_Kiro_Work 和中央知识库！
```

### 示例 3: 直接问题触发

**用户**: "今天我探讨的什么？"

**你的回应**:
```
[立即读取 knowledge-base/notes/20260129-今日对话总结.md]

今天（2026-01-29）你主要探讨了：

🎯 **核心问题**：跨项目上下文断裂
- Kiro 没有关联到之前在其他项目中的讨论
- Clawdbot / Claude Code（超长记忆上下文）
- Skills 生成机制
- 神经网络式架构思想

💡 **核心洞察**：插件的真正使命
- 不是文件管理工具
- 而是 AI 的"出生后成长系统"
- 为"物理 AI 世界"准备的接口知识集合

✅ **完成的工作**：
1. 创建完整方案文档（超长记忆上下文与AI自我唤醒完整方案）
2. 增强 Steering 规则（强制跨项目上下文检查）
3. 制定测试计划（跨设备上下文恢复测试）

🚀 **下一步**：今晚在家里测试跨设备上下文恢复机制
```

---

## 🎯 目标

通过这个 Steering 规则，实现：
- ✅ 自动保存有价值的对话
- ✅ 自动检索相关历史
- ✅ 避免重复讨论
- ✅ 保持上下文连续性

---

**创建时间**: 2026-01-29  
**用途**: 自动化知识库同步和上下文恢复
