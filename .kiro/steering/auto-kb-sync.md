---
inclusion: always
---

# 自动知识库同步

## 🎯 目标

自动同步本地知识库到中央知识库，避免手动操作。

---

## 📋 对话结束时

当对话结束或用户说"保存到知识库"时，你应该：

### 1. 评估对话质量

判断是否值得保存：
- ✅ 包含技术方案或解决方案
- ✅ 包含重要的讨论和决策
- ✅ 包含有价值的笔记和总结
- ❌ 只是简单的问答
- ❌ 没有实质内容

### 2. 确定保存位置

根据内容类型：
- **技术方案** → `solutions/`
- **笔记和总结** → `notes/`
- **讨论和决策** → `discussions/`

### 3. 生成文件名

格式：`YYYYMMDD-主题.md`

例如：
- `20260129-超长记忆上下文与AI自我唤醒完整方案.md`
- `20260129-Kiro-IDE-最佳实践指南.md`

### 4. 添加元数据

**必须包含**:
```yaml
---
domain: [领域]
tags: [标签列表]
date: YYYY-MM-DD
time: HH:MM (24小时制，例如 14:30)
location: [公司/家里/其他]
source_project: "K_Kiro_Work"
related_discussions:
  - "path/to/related/doc.md"
value_score: 1-10
---
```

**⚠️ 时间和地点的重要性**:
- `time`: 记录对话发生的具体时间，避免时间错乱
- `location`: 记录工作地点，帮助区分跨设备场景
- 这两个字段对于跨设备上下文恢复至关重要！

### 5. 提醒用户同步

保存到本地后，提醒用户：
```
✅ 已保存到本地知识库：
   knowledge-base/notes/20260129-xxx.md

⚠️ 请记得同步到中央知识库：
   Copy-Item "knowledge-base\notes\20260129-*.md" "D:\G_GitHub\Kiro-Central-KB\notes\"
```

---

## 🔍 对话开始时

当用户提出问题时，你应该：

### 1. 检查是否需要检索知识库

**🚨 强制触发条件（必须立即执行）**:

#### A. 时间关键词触发（🔴 最高优先级 - 优先于所有其他关键词）

**规则**: 如果用户问题中包含时间关键词，**必须先处理时间关键词**，忽略其他关键词！

| 时间关键词 | 立即执行 | 优先级 |
|-----------|---------|--------|
| "今天.*做.*什么" | 读取 `knowledge-base/notes/YYYYMMDD-今日对话总结.md` | 🔴 P0 |
| "今天.*探讨.*什么" | 读取 `knowledge-base/notes/YYYYMMDD-今日对话总结.md` | 🔴 P0 |
| "今天.*讨论.*什么" | 读取 `knowledge-base/notes/YYYYMMDD-今日对话总结.md` | 🔴 P0 |
| "今天" + 任何问题 | 读取 `knowledge-base/notes/YYYYMMDD-今日对话总结.md` | 🔴 P0 |
| "昨天.*做.*什么" | 读取昨日总结 | 🔴 P0 |
| "昨天.*讨论.*什么" | 读取昨日总结 | 🔴 P0 |
| "昨晚.*做.*什么" | 读取昨日总结 | 🔴 P0 |
| "昨晚.*测试" | 读取昨日总结 + 测试记录 | 🔴 P0 |
| "最近.*做.*什么" | 读取最近 3 天的总结 | 🔴 P0 |

**⚠️ 关键规则**:
- 时间关键词 **永远优先于** 技术关键词
- 即使问题中包含"跨设备"、"Hook"等技术关键词，如果有时间关键词，**先处理时间**
- 例如："今天在另一台设备做了什么？" → 先读取今日总结，不要被"另一台设备"误导

**🚨 时间和地点的准确性**:
- 读取文档后，**必须**检查 `time` 和 `location` 字段
- 回答时，**必须**使用文档中记录的准确时间和地点
- 不要猜测或推断时间和地点，只使用文档中的信息
- 如果文档中没有时间/地点信息，明确告诉用户"文档中未记录具体时间/地点"

#### B. 直接问题触发（🟠 高优先级）

用户说以下任何一句话时，**立即**读取对应文档：

| 用户问题 | 立即执行 | 优先级 |
|---------|---------|--------|
| "继续开发\|继续工作\|继续" | 读取完整上下文包（见下方详细说明） | 🟠 P1 |
| "我们之前讨论过..." | 检索中央知识库和本地知识库 | 🟠 P1 |
| "之前说过..." | 检索中央知识库和本地知识库 | 🟠 P1 |
| "保存到知识库" | 评估对话质量并保存 | 🟠 P1 |

**"继续"关键词的完整上下文包**:
```
1. SESSION-STATE.md（当前任务状态）
2. knowledge-base/notes/YYYYMMDD-今日对话总结.md（今日工作）
3. 最近修改的文件（Git diff，如果在 Git 仓库中）
4. 最近的错误日志（如果存在 .kiro/logs/ 或项目日志）
5. 相关项目的 README.md（如果在项目目录中）
```

**为什么这样做**:
- ✅ 提供完整的上下文，避免用户重复解释
- ✅ 像"真人"一样记得今天做了什么
- ✅ 自动关联相关信息，提升预判准确度

#### C. 技术关键词触发（🟡 中优先级）

**仅当没有时间关键词时**，才检查技术关键词：

**技术关键词**:
- Clawdbot, Claude Code, Claude-Mem → 超长记忆上下文
- Skills → 自动生成机制
- 神经网络 → AI 架构思想
- 胎儿期、成长 → AI 哲学
- 知识库、插件 → 架构设计
- 跨项目、上下文 → 上下文断裂问题
- Hook → 自动化、跨设备
- Ollama, Qwen → 本地 AI 系统
- 向量数据库, ChromaDB, Chroma → 超长记忆实现
- 预判、准确度 → AI 智能评估
- DevBrain → DevBrain-App 项目

**项目关键词**:
- Kiro-KB-Plugin → 检索插件项目文档
- DevBrain-App → 检索应用项目文档
- K_Kiro_Work → 当前项目
- 中央知识库 → 检索 `D:\G_GitHub\Kiro-Central-KB\`

**情感关键词**（模糊时间/状态查询）:
- "忙吗"、"怎么样"、"进展如何" → 读取今日总结 + 任务状态
- "累吗"、"辛苦了" → 读取今日总结 + 情感回应
- "有什么新发现" → 读取最近 3 天的总结

### 2. 主动检索知识库（不要等用户要求）

**检索顺序**:
1. **本地知识库优先** - 先检索当前项目的 `knowledge-base/`
2. **中央知识库次之** - 再检索 `D:\G_GitHub\Kiro-Central-KB\`
3. **其他项目最后** - 最后检索其他项目文档

**检索步骤**:
```
⚠️ 我发现这个话题之前可能讨论过（关键词：[匹配的关键词]）。

让我先检索知识库...

【本地知识库】
- 搜索 knowledge-base/notes/ 中的相关文档
- 搜索 knowledge-base/solutions/ 中的相关方案

【中央知识库】
- 读取 D:\G_GitHub\Kiro-Central-KB\INDEX.md
- 搜索相关关键词
- 读取找到的文档

【其他项目】
- 搜索 incubator/graduated/Kiro-KB-Plugin/docs/
- 搜索其他相关项目文档

请稍等...
```

**检索后必须做的事**:
1. ✅ 告诉用户找到了什么
2. ✅ 读取相关文档的完整内容
3. ✅ 基于历史上下文回答问题
4. ✅ 避免重复讨论

### 3. 引用相关讨论

如果找到相关讨论：
```
✅ 我在 [日期] 的 [项目名] 中发现了相关讨论：
- [文档标题]
- [文档路径]

让我先读取这些内容，避免重复讨论。
```

---

## 🤖 自动化流程

### 流程 A: 对话结束

```
用户对话结束
  ↓
评估对话质量
  ↓
确定保存位置
  ↓
生成文件名和元数据
  ↓
保存到本地知识库
  ↓
提醒用户同步到中央知识库
```

### 流程 B: 对话开始

```
用户提出问题
  ↓
检查关键词匹配
  ↓
如果匹配，检索中央知识库
  ↓
如果找到相关讨论，读取并引用
  ↓
基于历史上下文回答问题
```

---

## 📝 示例

### 示例 1: 对话结束时

**用户**: "保存到知识库"

**你的回应**:
```
✅ 评估对话质量：包含技术方案和架构设计，值得保存

✅ 保存位置：solutions/

✅ 文件名：20260129-超长记忆上下文与AI自我唤醒完整方案.md

✅ 元数据：
   - 时间：19:30（晚上 7:30）
   - 地点：家里
   - 项目：K_Kiro_Work

✅ 已保存到：knowledge-base/solutions/20260129-超长记忆上下文与AI自我唤醒完整方案.md

⚠️ 请记得同步到中央知识库：
   Copy-Item "knowledge-base\solutions\20260129-*.md" "D:\G_GitHub\Kiro-Central-KB\solutions\"
```

### 示例 2: 关键词触发检索

**用户**: "Hook 可以实现跨设备上下文恢复吗？"

**你的回应**:
```
⚠️ 我发现这个话题之前可能讨论过（关键词：Hook, 跨设备, 上下文）。

让我先检索知识库...

【本地知识库】
✅ 找到：knowledge-base/notes/20260129-今日对话总结.md
✅ 找到：docs/CROSS-DEVICE-TEST-PLAN.md

【其他项目】
✅ 找到：incubator/graduated/Kiro-KB-Plugin/docs/CROSS-DEVICE-CONTEXT-RECOVERY.md

让我读取这些文档...

[读取文档后]

是的！在 Kiro-KB-Plugin 项目中，我们设计了完整的跨设备上下文恢复机制：

1. **Hook: Sync Documentation on Source Changes**
   - 在源代码变更时自动同步文档

2. **自动上下文恢复（Steering 规则）**
   - 用户说"继续开发"时自动读取 SESSION-STATE.md
   - 自动恢复上下文

3. **跨设备工作流**
   - 离开设备时：更新 SESSION-STATE.md
   - 到达新设备时：让 Kiro 读取文档

这个机制可以应用到 K_Kiro_Work 和中央知识库！
```

### 示例 3: 时间关键词优先级（🔴 最高优先级）

**用户**: "今天在另一台设备做了什么？"

**❌ 错误的处理方式**:
```
⚠️ 我发现这个话题之前可能讨论过（关键词：另一台设备, 跨设备）。
让我先检索知识库...
[被"另一台设备"误导，开始检索跨设备相关文档]
```

**✅ 正确的处理方式**:
```
[检测到时间关键词"今天"，优先级 P0]
[立即读取 knowledge-base/notes/20260130-今日对话总结.md]

今天（2026-01-30）你主要做了：

🎯 **核心任务**：Clawdbot / Claude Code 超长记忆上下文技术调研

✅ **完成的工作**：
1. 完成 Clawdbot 技术调研报告
2. 发现 Claude-Mem 开源方案
3. 制定完整的实施路线图

🧪 **跨设备上下文恢复测试结果**：
- 总通过率: 96% (6.5/7)
- 平均评分: 9.6/10
- 结论: Steering 规则优化非常成功！

[注意：虽然问题中包含"另一台设备"，但时间关键词"今天"优先级更高]
```

### 示例 4: 直接问题触发

**用户**: "今天我探讨的什么？"

**你的回应**:
```
[立即读取 knowledge-base/notes/20260129-今日对话总结.md]

今天（2026-01-29）你主要探讨了：

🎯 **核心问题**：跨项目上下文断裂
- Kiro 没有关联到之前在其他项目中的讨论
- Clawdbot / Claude Code（超长记忆上下文）
- Skills 生成机制
- 神经网络式架构思想

💡 **核心洞察**：插件的真正使命
- 不是文件管理工具
- 而是 AI 的"出生后成长系统"
- 为"物理 AI 世界"准备的接口知识集合

✅ **完成的工作**：
1. 创建完整方案文档（超长记忆上下文与AI自我唤醒完整方案）
2. 增强 Steering 规则（强制跨项目上下文检查）
3. 制定测试计划（跨设备上下文恢复测试）

🚀 **下一步**：今晚在家里测试跨设备上下文恢复机制
```

---

## 🎯 目标

通过这个 Steering 规则，实现：
- ✅ 自动保存有价值的对话
- ✅ 自动检索相关历史
- ✅ 避免重复讨论
- ✅ 保持上下文连续性

---

**创建时间**: 2026-01-29  
**用途**: 自动化知识库同步和上下文恢复
